#!/usr/bin/env python3
import json
from functools import cmp_to_key
from inspect import getsource
from sys import argv
import re

complete_match = ["""import json as a,sys
b=sys.argv
a.dump(dict(zip(*[sorted(x)for x in a.load(open(b[1]))])),open(b[2],'w'))""",
                      """import json as a,sys,re
b=sys.argv
a.dump(dict(zip(*[sorted(i,key=lambda y:[int(c)if c.isdigit()else c for c in re.split('(\d+)',y)])for i in a.load(open(b[1]))])),open(b[2],'w'))""",
                      """import json as a,sys,re
def dimensions(string,i):
    it=list(re.finditer('\[([0-9]+)\]'*i,string))
    return (0,0) if not i else (i,it) if len(it) else dimensions(string,i-1)
def order_key(ori):
    K=ori[:]
    order=re.findall('\$[a-zA-Z](\d+)',ori)
    if order:
        d,ds = dimensions(ori,2)
        o=int(order[0])
        if d:
            K = ori[:ds[0].start()]+ds[-1 if len(ds) < o else o-1].group(0)+order[0]
        else:
            x_dim = list(re.finditer('[a-zA-Z]\d+\_\d+',ori))
            K= ori[:x_dim[0].start()]+x_dim[-1 if len(x_dim) < o else o-1].group(0)+order[0] if x_dim else ori
    else:
        K = ori
    return [int(c)if c.isdigit()else c for c in re.split('(\d+)',K)]
A=[ sorted(i) for i in a.load(open(b[1]))]
X=[[order_key(j)for j in i] for i in A]
Y=[[*zip(A[i],X[i])] for i in[0,1]]
Y=[sorted(x,key=lambda y:y[1]) for x in Y]
A=[[z[0]for z in y]for y in Y]
a.dump(dict(zip(*A)),open(b[2],'w'))"""]
    
incomplete_match = ["""import json as a,sys
b=sys.argv
A=[sorted(x)for x in a.load(open(b[1]))]
t={}
B=A[1][:]
D=[]
C=0
for i in range(0,len(t),2):
    if type(t[i])!=list:
        D+=[B[t[i]+C+j]for j in range(t[i+1])]
        C+=t[i+1]
    else:
        D+=[B[t[i][j]+C+j]for j in range(len(t[i]))]
        C+=len(t[i])
A[1]=D
a.dump(dict(zip(*A)),open(b[2],'w'))""",
                        '''import json as a,sys,re
t={}
b=sys.argv
A=[sorted(i,key=lambda y:[int(c)if c.isdigit()else c for c in re.split('(\d+)',y)])for i in a.load(open(b[1]))]
B=A[1][:]
D=[]
C=0
for i in range(0,len(t),2):
    if type(t[i])!=list:
        D+=[B[t[i]+C+j]for j in range(t[i+1])]
        C+=t[i+1]
    else:
        D+=[B[t[i][j]+C+j]for j in range(len(t[i]))]
        C+=len(t[i])
A[1]=D
a.dump(dict(zip(*A)),open(b[2],'w'))''',
                         """import json as a,sys,re
def dimensions(string,i):
    it=list(re.finditer('\[([0-9]+)\]'*i,string))
    return (0,0) if not i else (i,it) if len(it) else dimensions(string,i-1)
def order_key(ori):
    K=ori[:]
    order=re.findall('\$[a-zA-Z](\d+)',ori)
    if order:
        d,ds = dimensions(ori,2)
        o=int(order[0])
        if d:
            K = ori[:ds[0].start()]+ds[-1 if len(ds) < o else o-1].group(0)+order[0]
        else:
            x_dim = list(re.finditer('[a-zA-Z]\d+\_\d+',ori))
            K= ori[:x_dim[0].start()]+x_dim[-1 if len(x_dim) < o else o-1].group(0)+order[0] if x_dim else ori
    else:
        K = ori
    return [int(c)if c.isdigit()else c for c in re.split('(\d+)',K)]
t={}
b=sys.argv
A=[ sorted(i) for i in a.load(open(b[1]))]
X=[[order_key(j)for j in i] for i in A]
Y=[list(zip(A[i],X[i])) for i in[0,1]]
Y=[sorted(x,key=lambda y:y[1]) for x in Y]
A=[[z[0]for z in y]for y in Y]
B=A[1][:]
D=[]
C=0
for i in range(0,len(t),2):
    if type(t[i])!=list:
        D+=[B[t[i]+C+j]for j in range(t[i+1])]
        C+=t[i+1]
    else:
        D+=[B[t[i][j]+C+j]for j in range(len(t[i]))]
        C+=len(t[i])
A[1]=D
a.dump(dict(zip(*A)),open(b[2],'w'))"""]

order_key_scripts = ['''import json as a,sys,re
b=sys.argv
N=lambda x:[int(c)if c.isdigit()else c for c in re.split('(\d+)',x)]
def _(A):
    B=''
    D=re.findall('\$[a-zA-Z]\d+',A)
    if not D:
        return N(A)
    F=re.split('/',A) 
    O=[(i.find(D[0])!=-1)for i in F].index(True)
    T= '/'.join(F[:O-1])
    m=re.split('{0}',F[O-1])
    return N((T+'/'if T else'')+m[int(D[0][2:])-1])
a.dump(dict(zip(*[sorted(i,key=_)for i in a.load(open(b[1]))])),open(b[2],'w'))''',
'''import json as a,sys,re
b=sys.argv
N=lambda x:[int(c)if c.isdigit()else c for c in re.split('(\d+)',x)]
def _(A):
    B=''
    D=re.findall('\$[a-zA-Z]\d+',A)
    if not D:
        return N(A)
    F=re.split('/',A) 
    O=[(i.find(D[0])!=-1)for i in F].index(True)
    T= '/'.join(F[:O-1])
    m=re.split('{0}',F[O-1])
    C=re.split('{1}',m[0])
    m[0]=m[0]if len(C)==1 else C[1]
    return N((T+'/'if T else'')+m[int(D[0][2:])-1])
a.dump(dict(zip(*[sorted(i,key=_)for i in a.load(open(b[1]))])),open(b[2],'w'))''']

separator = ''
prefix = ''

def shift_count(ori,new):
    count = 0
    for i in range(len(ori)):
        if ori[new[0][i]] != new[1][i]:
            count += 1
    return count

def generate_shift_table(ori,new):
    idx=[]
    for i in range(len(ori)):
        if ori[new[0][i]] != new[1][i]:
            idx.append(new[1].index(ori[new[0][i]])-i)
        else:
            idx.append(0)
    return idx

def generate_run_length_table(idx):
    # [initialization]
    # add end flag
    idx += ['*']  
    # current run
    current = idx[0] 
    # current length
    run_length = 0
    # final output info
    res = []
    # readble output info
    readable = []
    
    # [run_length]
    for i in range(len(idx)):
        if idx[i] == current:
            run_length += 1
        else:
            res += [current,run_length]
            readable.append([current,run_length])
            current = idx[i]
            run_length = 1
    return res, readable

def two_level_run_length(table):
    flag = False
    temp = []
    tltable = []
    for i in range(0,len(table),2):
        if not flag and table[i+1] == 1:
            temp = [[table[i]],1]
            flag = True
        elif flag and table[i+1] == 1:
            temp[0] += [table[i]]
        else:
            flag = False
            tltable += temp
            tltable += table[i:i+2]
            temp = []
    tltable += temp
    return tltable

def generate_tables(origin_table, input_table, method):
    methods = ['Default', 'Natural', 'Order']
    choise, idx, res, readable, tltable = -1, [], [], [], []
    ns = shift_count(origin_table, input_table)
    if ns == 0:
        print('%s key can sovle this case.' % method)
        choise = methods.index(method)
    else:
        print('%s key can\'t sovle this case.' % method)
        print('Shift count in this method: %d.' % ns)
        idx = generate_shift_table(origin_table,input_table)
        res, readable = generate_run_length_table(idx)
        tltable = two_level_run_length(res)
        print('Shift table string length: %d.' % len(str(idx)))
        print('One level run-length table string length: %d.' % len("".join(str(res).split(' '))))
        print('The most large consecutive segment length: %d.' % max(list(zip(*readable))[1]))
        print('Two level run-length table string length: %d.' % len("".join(str(tltable).split(' '))))
    return choise, idx, res, readable, tltable

def default_key_method(origin_mapping):
    keys, values = zip(*origin_mapping.items())
    keys, values = sorted(keys), sorted(values)
    return [keys,values]

def natural_key(x):
    return [int(c)if c.isdigit()else c for c in re.split('(\d+)',x)]

def natural_key_method(origin_mapping):
    ori = [list(origin_mapping.keys()),list(origin_mapping.values())]
    return [sorted(x,key=natural_key) for x in ori]

def dimensions(string,i):
    it=list(re.finditer('\[([0-9]+)\]'*i,string))
    return (0,0) if not i else (i,it) if len(it) else dimensions(string,i-1)

def order_key(ori):
    K=ori[:]
    order=re.findall('\$[a-zA-Z](\d+)',ori)
    if order:
        d,ds = dimensions(ori,2)
        o=int(order[0])
        if d:
            K = ori[:ds[0].start()]+ds[-1 if len(ds) < o else o-1].group(0)+order[0]
        else:
            x_dim = list(re.finditer('[a-zA-Z]\d+\_\d+',ori))
            K= ori[:x_dim[0].start()]+x_dim[-1 if len(x_dim) < o else o-1].group(0)+order[0] if x_dim else ori
    else:
        K = ori
    return [int(c)if c.isdigit()else c for c in re.split('(\d+)',K)]

def find_separator_prefix(origin_mapping):
    voting = dict()
    have_order = [(k,v) for k, v in origin_mapping.items() if re.findall('\$[a-zA-Z]\d+',k) or re.findall('\$[a-zA-Z]\d+',v)]
    ko = [(k,v) for k, v in origin_mapping.items() if re.findall('\$[a-zA-Z]\d+',k)] 
    vo = [(k,v) for k, v in origin_mapping.items() if re.findall('\$[a-zA-Z]\d+',v)]
    if not (ko or vo):
        return '', ''
    flag = True if ko else False 
    for k, v in have_order:
        Order=re.search('\$[a-zA-Z](\d+)', k if flag else v)
        ks = re.split('/',k)
        vs = re.split('/',v)
        opos =[(i.find(Order.group(0))!=-1)for i in (ks if flag else vs)].index(True)
        folders = ks[opos-1] if flag else vs[opos-1] 
        folders = re.sub('\d+','',folders)
        folder = re.sub('\d+','',vs[opos-1] if flag else ks[opos-1])
        patterns = re.split(re.escape(folder),folders)
        for pattern in [i for i in patterns if i]:
            if pattern in voting:
                voting[pattern] += 1
            else:
                voting.setdefault(pattern,1)      
    if not voting:
        return '', ''
    voting = sorted(list(voting.items()),key=lambda x:x[1],reverse=True)
    return voting[0][0], (voting[1][0] if len(voting) > 1 and voting[0][0] not in voting[1][0] else '')

def _order_key(ori,sep,pre):
    new  =  ori[:]
    match = re.findall('\$[a-zA-Z]\d+',ori)
    if match:
        m1=re.split('/',  ori) 
        opos =[(i.find(match[0])!=-1)for i in m1].index(True)
        temp = '/'.join(m1[:opos-1])
        m=re.split(sep,m1[opos-1])
        new=(temp+'/' if temp else '')+m[int(match[0][2:])-1]
    else:       
        new=ori
    return [int(c)if c.isdigit()else c for c in re.split('(\d+)',new)]

def order_key_(ori,sep,pre):
    new  =  ori[:]
    match = re.findall('\$[a-zA-Z]\d+',ori)
    if match:
        m1=re.split('/',  ori) 
        opos =[(i.find(match[0])!=-1)for i in m1].index(True)
        temp = '/'.join(m1[:opos-1])
        m=re.split(sep,m1[opos-1])
        cut=re.split(pre,m[0])
        m[0] = m[0]if len(cut) == 1 else cut[1]
        new=(temp+'/' if temp else '')+m[int(match[0][2:])-1]
    else:       
        new=ori
    return [int(c)if c.isdigit()else c for c in re.split('(\d+)',new)]

def order_key_method(origin_mapping):
    global separator
    global prefix
    separator, prefix = find_separator_prefix(origin_mapping)
    print('Separator: %s. Prefix pattern: %s.' % ( (separator if separator else 'None'),(prefix if prefix else 'None') ) ) 
    if not(separator or prefix):
        return []
    ori=[sorted(list(origin_mapping.keys())),sorted(list(origin_mapping.values()))]
    func=order_key_ if prefix else _order_key
    _ori=[[func(j,separator,prefix)for j in i] for i in ori]
    KV=[list(zip(ori[i],_ori[i])) for i in[0,1]]
    KV=[sorted(x,key=lambda x:x[1]) for x in KV]
    return [[z[0]for z in y]for y in KV]

def check_type(origin_mapping):
    output_script = ""
    choise = -1
    methods = ['Default', 'Natural', 'Order']
    functions = [default_key_method, natural_key_method, order_key_method]
    data = [ [ [] for j in range(4) ] for i in range(len(methods)) ] # index, one level run-length, readable, two level run-length
    for i in range(len(methods)):
        if choise == -1:
            input_table = functions[i](origin_mapping)   
            if not input_table:
                print('%s key can\'t apply to this case.' % methods[i])
                continue
            flag, data[i][0], data[i][1], data[i][2], data[i][3] = generate_tables(origin_mapping, input_table, methods[i])
            choise = i if flag == i else -1   
    if choise != -1:
        if choise != 2:
            output_script = complete_match[choise]
        else:
            global prefix
            global separator
            if prefix:
                output_script = order_key_scripts[1].format(separator,prefix)
            else:
                output_script = order_key_scripts[0].format(separator)
    else:
        print('No method can solve this case.')
        total= lambda x,y: len("".join(str(x).split(' ')))+len(y)
        two_level = [(methods[i],total(data[i][3],incomplete_match[i]))if data[i][0] else (methods[i],-1) for i in range(len(methods))] 
        two_level = list(filter(lambda x: x[1] > -1,sorted(two_level,key=lambda x:x[1])))
        t_index = methods.index(two_level[0][0])
        script_candidate = [ (len("".join(str(data[i][3]).split(' '))),len(incomplete_match[i]),total(data[i][3],incomplete_match[i]))for i in range(len(methods)) ]
        print('Script candidate: %s.' % str(dict(zip(methods,script_candidate))) )
        print('Using %s key table to record the original relationship.' % methods[t_index])
        index, one_level, readable, two_level = data[t_index][0], data[t_index][1], data[t_index][2], data[t_index][3] 
        output_script = incomplete_match[t_index].format("".join(str(two_level).split(' ')))
    print('Script size: %d.' % len(output_script))
    return output_script
if __name__ == '__main__':
    map_in_name, script_name = argv[1], argv[2]
    print(map_in_name)
    map_in_file = open(map_in_name)
    origin_mapping = json.load(map_in_file)
    map_in_file.close()
    output_script = check_type(origin_mapping)
 

  
    script=open(script_name,'w')   
    script.write(output_script)
    script.close()
