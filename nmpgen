#!/usr/bin/env python3
import json
from functools import cmp_to_key
from inspect import getsource
from sys import argv
import re
import gzip

def consecu_int_run_length(size,idx):
    mark = []
    flag = False
    temp = []
    for i in range(size):
        if i != idx[i]:      
            if flag == False:
                temp = [ i, idx[i], 1 ]
                flag = True
            elif flag == True and idx[i]-(temp[1]+temp[2]) == 0:
                temp[2] += 1
            elif flag == True:
                mark += temp
                temp = [ i, idx[i], 1 ]
                flag = True
        else:
            if flag == True:
                mark += temp
                temp = []
                flag = False
    if len(temp) != 0:
        mark += temp
    return mark

def sporadic_seg_run_length(mark):
    sporadic_seg = [ mark[i:i+3] for i in range(0,len(mark),3)]
    flag = False
    temp = []
    res = []
    for i in range(len(sporadic_seg)):
        if sporadic_seg[i][2] != 1:
            if flag == True:
                res += temp 
                # initialize temp to an empty list, to avoid if temp have something but index is at the end
                temp = []
                flag = False
            res += sporadic_seg[i]
        else:
            # first one
            if flag == False:
                # start index, index list, len
                temp = [sporadic_seg[i][0],[sporadic_seg[i][1]],1]
                flag = True
            else:
                if sporadic_seg[i][0] - sporadic_seg[i-1][0] == 1:
                    temp[1].append(sporadic_seg[i][1]) 
                else:
                    res += temp  
                    temp = [sporadic_seg[i][0],[sporadic_seg[i][1]],1]
    if len(temp) != 0:
        res += temp  
    return res

def classify(origin_mapping):
    same, prefix, infix, postfix, others = [], [], [], [], []
    for k,v in origin_mapping.items():
        index = v.find(k)
        if k == v:
            same += [k]
        elif index != -1:
            if index == 0:
                prefix += [k]
            elif v[index:] == k:
                postfix += [k]
            else:
                infix += [k]
        else:
            others += [k]
    return same, prefix, infix, postfix, others
    
g=len
def p(x,y):
    d,b=g(x[0]),g(y[0])
    if x[1]==y[1]:
        if d-b:
            return 1 if d>b else -1
        else:
            for i in range(d):
                if x[0][i]==y[0][i]:
                    continue
                return 1 if int(x[0][i])>int(y[0][i]) else -1       
            return 0
    return 1 if x[1]>y[1] else -1
    
def extract_remove(lst):
    remove, extract = [], []
    for i in range(len(lst)):
        integers = re.findall('([0-9]+)',lst[i])
        if len(integers) != 0:
            integer_lst = list(re.finditer('([0-9]+)',lst[i]))
            cpy = lst[i][:]
            for j in range(len(integer_lst)):
                cpy = cpy.replace(integer_lst[j].group(0),'',1)
            remove.append(cpy)
        else:
            remove.append(lst[i])
        extract.append(integers)
    return extract, remove

def shift_count(ori,new):
    count = 0
    for k,v in ori.items():
        if new[k] != v:
            count += 1
    print('shift count:',count)
    return count

def bit_size(lst):
    maximum = 0
    for item in lst:
        all_int = re.findall('\d+',item)
        if not all_int:
            continue
        maximum = max(maximum, (len(all_int[0]) if len(all_int) == 1 else max([*map(len,all_int)])))        
    return maximum

def zfill_method(origin_mapping,maximum):
    # mmm=[k:('','',...),v:('','',...)] 
    ori=[*zip(*origin_mapping.items())]

    # ori_zfill =[0:['','',...],1:['','',...]]
    ori_zfill=[*map(lambda x:[*map(lambda y:re.sub(r'(\d+)',lambda z:z.group(1).zfill(maximum),y),x)],ori)]

    # ori_and_zfill = [[(k1,kf1),(k2,kf2),...],[(v1,vf1),(v2,vf2),...]]
    ori_and_zfill=[*map(lambda x,y:[*zip(x,y)],ori,ori_zfill)]

    # sort_by_zfill = [[(k1,kf1),(k2,kf2),...],[(v1,vf1),(v2,vf2),...]]
    sort_by_zfill=[*map(lambda x:sorted(x,key=lambda y:y[1]),ori_and_zfill)]

    # transpose=[0:[(k1,k2,...),(kf1,kf2,...)],1:[(v1,v2,...),(vf1,vf2,...)]] 
    transpose = [*map(lambda x: [*zip(*x)],sort_by_zfill)]
    new_table=dict(zip(transpose[0][0],transpose[1][0]))
    return shift_count(origin_mapping,new_table), generate_idx_list([*zip(*ori_zfill)])

def generate_idx_list(pack):
    pack.sort(key=lambda x: x[0]) 
    k,v = zip(*pack)        
    mm = sorted(zip(v,[i for i in range(len(k))]),key=lambda x: x[0])
    v, idx = zip(*mm) 
    idx = list(idx)
    mark = consecu_int_run_length(len(pack),idx)
    print('consecu idx list char count: {}'.format(len(str(mark))))
    sporadic_seg = sporadic_seg_run_length(mark)
    print('sporadic_seg idx list char count: {}'.format(len(str(sporadic_seg))))
    return mark,sporadic_seg

def check_type(origin_mapping):
    flag = 0
    maximum = max(bit_size(origin_mapping.keys()),bit_size(origin_mapping.values()))
    keys, values = zip(*origin_mapping.items())
    keys, values = sorted(keys), sorted(values)
    for i in range(len(keys)):
        if values[i] != origin_mapping[keys[i]]:
            flag = 1
            break
    if flag == 0:
        return 0
    
    # zfill_method
    if not zfill_method(origin_mapping,maximum)[0]:
        print('zfill type')
        return 1
        
    return 2
    
if __name__ == '__main__':
    map_in_name, script_name = argv[1], argv[2]

    map_in_file = open(map_in_name)
    origin_mapping = json.load(map_in_file)
    map_in_file.close()
    output_script_type = check_type(origin_mapping)
    print('type:',output_script_type)
    mark,sporadic_seg=generate_idx_list(list(origin_mapping.items()))
    document2 = """import json as a,sys 
w={}
n,o=sys.argv[1:3]
k,v=a.load(open(n))
s=sorted
k,v=s(k),s(v)
l=len
g=range
m=dict(zip(k,v))
for i in g(0,l(w),3):
    if w[i+2]!=1:
        for j in g(w[i+2]):
            m[k[w[i+1]+j]]=v[w[i]+j]
    else:
        for j in g(l(w[i+1])):
            m[k[w[i+1][j]]]=v[w[i]+j]
a.dump(m,open(o,'w'))""".format(str(sporadic_seg))

    document0 = """import json as a,sys
n,o=sys.argv[1:3]
k,v=a.load(open(n))
s=sorted
a.dump(dict(zip(s(k),s(v))),open(o,'w'))"""

    document4 = """import json as a,sys,re
from functools import cmp_to_key
g=len
s=sorted
def p(x,y):
    d,b=g(x[0]),g(y[0])
    if x[1]==y[1]:
        if d-b:
            return 1 if d>b else -1
        else:
            for i in range(d):
                if x[0][i]==y[0][i]:
                    continue
                return 1 if int(x[0][i])>int(y[0][i]) else -1       
            return 0
    return 1 if x[1]>y[1] else -1
def t(l):
    r,e=[],[]
    for i in range(g(l)):
        y=re.findall('([0-9]+)',l[i])
        if g(y) != 0:
            d = list(re.finditer('([0-9]+)',l[i]))
            c=l[i][:]
            for j in range(len(d)):
                c=c.replace(d[j].group(0),'',1)
            r.append(c)
        else:
            r.append(l[i])
        e.append(y)
    return e,r
n,o=sys.argv[1:3]
k,v=a.load(open(n))
w,x=t(k)
y,z=t(v)
c=s(zip(w,x,k),key=cmp_to_key(p))
b=s(zip(y,z,v),key=cmp_to_key(p))
a.dump(dict([(c[i][2],b[i][2]) for i in range(g(c))]),open(o,'w'))"""

    document1 = """import json as a,sys,re
n,o=sys.argv[1:3]
A=a.load(open(n))
B=[*map(lambda x:[*zip(*x)],[*map(lambda x:sorted(x,key=lambda y:y[1]),[*map(lambda m,n:[*zip(m,n)],A,[*map(lambda x:[*map(lambda y:re.sub(r'(\d+)',lambda z:z.group(1).zfill({}),y),x)],A)])])])]
a.dump(dict(zip(B[0][0],B[1][0])),open(o,'w'))""".format(max(bit_size(origin_mapping.keys()),bit_size(origin_mapping.values())))

    script=open(script_name,'w')
    doc=''
    if output_script_type == 0:
        doc=document0
    elif output_script_type == 1:
        doc=document1
    else:
        doc=document2
    
    script.write(doc)
    #print(len(doc),len(gzip_ver)+len(gzip_doc))
    #script.write(doc if len(doc) < len(gzip_ver)+len(gzip_doc) else gzip_ver)
    #script.write(gzip_ver)
    script.close()
