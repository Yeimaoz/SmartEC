#!/usr/bin/env python3
import json
from functools import cmp_to_key
from inspect import getsource
from sys import argv
import re

def consecu_int_run_length(idx):
    mark = []
    flag = False
    temp = []
    for i in range(len(k)):
        if i != idx[i]:      
            if flag == False:
                temp = [ i, idx[i], 1 ]
                flag = True
            elif flag == True and idx[i]-(temp[1]+temp[2]) == 0:
                temp[2] += 1
            elif flag == True:
                mark += temp
                temp = [ i, idx[i], 1 ]
                flag = True
        else:
            if flag == True:
                mark += temp
                temp = []
                flag = False
    if len(temp) != 0:
        mark += temp
    return mark

def sporadic_seg_run_length(mark):
    sporadic_seg = [ mark[i:i+3] for i in range(0,len(mark),3)]
    flag = False
    temp = []
    res = []
    for i in range(len(sporadic_seg)):
        if sporadic_seg[i][2] != 1:
            if flag == True:
                res += temp 
                # initialize temp to an empty list, to avoid if temp have something but index is at the end
                temp = []
                flag = False
            res += sporadic_seg[i]
        else:
            # first one
            if flag == False:
                # start index, index list, len
                temp = [sporadic_seg[i][0],[sporadic_seg[i][1]],1]
                flag = True
            else:
                if sporadic_seg[i][0] - sporadic_seg[i-1][0] == 1:
                    temp[1].append(sporadic_seg[i][1]) 
                else:
                    res += temp  
                    temp = [sporadic_seg[i][0],[sporadic_seg[i][1]],1]
    if len(temp) != 0:
        res += temp  
    return res

def classify(origin_mapping):
    same, prefix, infix, postfix, others = [], [], [], [], []
    for k,v in origin_mapping.items():
        index = v.find(k)
        if k == v:
            same += [k]
        elif index != -1:
            if index == 0:
                prefix += [k]
            elif v[index:] == k:
                postfix += [k]
            else:
                infix += [k]
        else:
            others += [k]
    return same, prefix, infix, postfix, others
    
g=len
def p(x,y):
    d,b=g(x[0]),g(y[0])
    if x[1]==y[1]:
        if d-b:
            return 1 if d>b else -1
        else:
            for i in range(d):
                if x[0][i]==y[0][i]:
                    continue
                return 1 if int(x[0][i])>int(y[0][i]) else -1       
            return 0
    return 1 if x[1]>y[1] else -1
    
def extract_remove(lst):
    remove, extract = [], []
    for i in range(len(lst)):
        integers = re.findall('([0-9]+)',lst[i])
        if len(integers) != 0:
            integer_lst = list(re.finditer('([0-9]+)',lst[i]))
            cpy = lst[i][:]
            for j in range(len(integer_lst)):
                cpy = cpy.replace(integer_lst[j].group(0),'',1)
            remove.append(cpy)
        else:
            remove.append(lst[i])
        extract.append(integers)
    return extract, remove

def check_type(origin_mapping):
    flag = 0
    keys, values = zip(*origin_mapping.items())
    keys, values = sorted(keys), sorted(values)
    for i in range(len(keys)):
        if values[i] != origin_mapping[keys[i]]:
            flag = 1
            break
    if flag == 0:
        return 0
    kv_lst = sorted(list(origin_mapping.items()),key=lambda x: x[0])
    
    # divide kv_list to k and v
    k,v = zip(*kv_lst)
    k = list(k)
    v = list(v)   
    
    # ke: extraction of int of key
    # ve: extraction of int of value
    # kr: string removed int part of key
    # vr: string removed int part of value
    ke, kr = extract_remove(k)
    ve, vr = extract_remove(v)
    table = list(zip(ke,kr,ve,vr,k,v))
    table = sorted(table,key=cmp_to_key(p))      

    t0,t1,t2,t3,t4,t5 = zip(*table)
    check_table = list(zip(t2,t3,[i for i in range(len(k))]))
    check_table = sorted(check_table,key=cmp_to_key(p))
    ccc = 0
    for i in range(len(k)):
        if check_table[i][2] != i:
            ccc += 1
    if ccc == 0:
        return 1
    return 2
    
if __name__ == '__main__':
    map_in_name, script_name = argv[1], argv[2]

    map_in_file = open(map_in_name)
    origin_mapping = json.load(map_in_file)
    map_in_file.close()
    output_script_type = check_type(origin_mapping)
    
    # rule based classifying
    same, prefix, infix, postfix, others = classify(origin_mapping)
   
    # only remove same
    same_set = set(same)
    exclusive_same = dict([item for item in origin_mapping.items() if item[0] not in same_set])
    mmm = sorted(list(exclusive_same.items()),key=lambda x: x[0])

    k,v = zip(*mmm)
    k = list(k)
    v = list(v)          
    mm = sorted(zip(v,[ i for i in range(len(k)) ]),key=lambda x: x[0])
    v, idx = zip(*mm) 
    idx = list(idx)
    mark = consecu_int_run_length(idx)
    sporadic_seg = sporadic_seg_run_length(mark)
    
    document2 = """import json as a,sys 
w={}
n,o=sys.argv[1:3]
k,v=a.load(open(n))
s=sorted
k,v=set(k),set(v)
r=k&v
c=list(r)
m=dict(zip(c,c))
k,v=s(k-r),s(v-r)
l=len
g=range
for i in g(l(k)):
    m[k[i]]=v[i]
for i in g(0,l(w),3):
    if w[i+2]!=1:
        for j in g(w[i+2]):
            m[k[w[i+1]+j]]=v[w[i]+j]
    else:
        for j in g(l(w[i+1])):
            m[k[w[i+1][j]]]=v[w[i]+j]
a.dump(m,open(o,'w'))""".format(str(sporadic_seg))

    document0 = """import json as a,sys
n,o=sys.argv[1:3]
k,v=a.load(open(n))
s=sorted
a.dump(dict(zip(s(k),s(v))),open(o,'w'))"""

    document1 = """import json as a,sys,re
from functools import cmp_to_key
g=len
s=sorted
def p(x,y):
    d,b=g(x[0]),g(y[0])
    if x[1]==y[1]:
        if d-b:
            return 1 if d>b else -1
        else:
            for i in range(d):
                if x[0][i]==y[0][i]:
                    continue
                return 1 if int(x[0][i])>int(y[0][i]) else -1       
            return 0
    return 1 if x[1]>y[1] else -1
def t(l):
    r,e=[],[]
    for i in range(g(l)):
        y=re.findall('([0-9]+)',l[i])
        if g(y) != 0:
            d = list(re.finditer('([0-9]+)',l[i]))
            c=l[i][:]
            for j in range(len(d)):
                c=c.replace(d[j].group(0),'',1)
            r.append(c)
        else:
            r.append(l[i])
        e.append(y)
    return e,r
n,o=sys.argv[1:3]
k,v=a.load(open(n))
w,x=t(k)
y,z=t(v)
c=s(zip(w,x,k),key=cmp_to_key(p))
b=s(zip(y,z,v),key=cmp_to_key(p))
a.dump(dict([(c[i][2],b[i][2]) for i in range(g(c))]),open(o,'w'))"""

    script=open(script_name,'w')
    doc=''
    if output_script_type == 0:
        doc=document0
    elif output_script_type == 1:
        doc=document1
    else:
        doc=document2
    script.write(doc)
    script.close()
